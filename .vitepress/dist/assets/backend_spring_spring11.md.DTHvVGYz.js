import{$ as t,U as n,c as a,aA as l,ab as i,S as o}from"./chunks/framework.BDLhZlrp.js";const p="/knowledge-map/assets/image-20221218154841001.DwDCZRUq.png",r="/knowledge-map/assets/image-20221207113544080.VBJrUcf4.png",g="/knowledge-map/assets/image-20221207153944132.Cx9i8-NX.png",h="/knowledge-map/assets/image-20221207152841304.BXUJzoAA.png",m="/knowledge-map/assets/image-20221207110539954.zphjEale.png",d="/knowledge-map/assets/image-20221207153724340.ispQ_CNG.png",c="/knowledge-map/assets/image-20221207153755732.CMDQB5sm.png",_="/knowledge-map/assets/image-20221207153642253.DoBF5YCJ.png",k="/knowledge-map/assets/image-20221207155009832.CquFzNUS.png",u="/knowledge-map/assets/image-20221219112426052.3hx98Cn_.png",v="/knowledge-map/assets/image-20221207155726572.DHoJH5FK.png",b="/knowledge-map/assets/image-20221207155756512.BD7T-FcS.png",J="/knowledge-map/assets/image-20221207110947997.DuZ4DbQv.png",y="/knowledge-map/assets/image-20221207111012582.NeVdDHEc.png",E="/knowledge-map/assets/image-20221207111105569.DDwS7iDf.png",q="/knowledge-map/assets/image-20221207111206279.DozlzZg2.png",T="/knowledge-map/assets/image-20221207111420056.BoewtOsj.png",A="/knowledge-map/assets/image-20221207111509837.DMtEO5aV.png",V="/knowledge-map/assets/image-20221207111609878.BhlbyF6G.png",f="/knowledge-map/assets/image-20221207111644950.BEYzcCMU.png",w="/knowledge-map/assets/image-20221207111731150.2vnC0_zT.png",z="/knowledge-map/assets/image-20221207111947283.DQ3YF2QB.png",C="/knowledge-map/assets/image-20221207112009852.C-4VNGlE.png",B=JSON.parse('{"title":"11. 提前编译：AOT","description":"","frontmatter":{"prev":{"text":"10. 数据校验：Validation","link":"/backend/spring/spring10"},"next":false},"headers":[],"relativePath":"backend/spring/spring11.md","filePath":"backend/spring/spring11.md","lastUpdated":1721299010000}'),M={name:"backend/spring/spring11.md"},x=l('<h1 id="_11-提前编译-aot" tabindex="-1">11. 提前编译：AOT <a class="header-anchor" href="#_11-提前编译-aot" aria-label="Permalink to &quot;11. 提前编译：AOT&quot;">​</a></h1><p><img src="'+p+'" alt="image-20221218154841001" loading="lazy"></p><h2 id="_11-1-aot-概述" tabindex="-1">11.1 AOT 概述 <a class="header-anchor" href="#_11-1-aot-概述" aria-label="Permalink to &quot;11.1 AOT 概述&quot;">​</a></h2><h3 id="_11-1-1-jit-与-aot-的区别" tabindex="-1">11.1.1 JIT 与 AOT 的区别 <a class="header-anchor" href="#_11-1-1-jit-与-aot-的区别" aria-label="Permalink to &quot;11.1.1 JIT 与 AOT 的区别&quot;">​</a></h3><p>JIT 和 AOT 这个名词是指两种不同的编译方式，这两种编译方式的主要区别在于是否在“运行时”进行编译</p><p><strong>（1）JIT， Just-in-time,动态(即时)编译，边运行边编译；</strong></p><p>在程序运行时，根据算法计算出热点代码，然后进行 JIT 实时编译，这种方式吞吐量高，有运行时性能加成，可以跑得更快，并可以做到动态生成代码等，但是相对启动速度较慢，并需要一定时间和调用频率才能触发 JIT 的分层机制。JIT 缺点就是编译需要占用运行时资源，会导致进程卡顿。</p><p><strong>（2）AOT，Ahead Of Time，指运行前编译，预先编译。</strong></p><p>AOT 编译能直接将源代码转化为机器码，内存占用低，启动速度快，可以无需 runtime 运行，直接将 runtime 静态链接至最终的程序中，但是无运行时性能加成，不能根据程序运行情况做进一步的优化，AOT 缺点就是在程序运行前编译会使程序安装的时间增加。</p><p>**简单来讲：**JIT 即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.java -&gt; .class -&gt; (使用jaotc编译工具) -&gt; .so（程序函数库,即编译好的可以供其他程序使用的代码和数据）</span></span></code></pre></div><p><img src="'+r+'" alt="image-20221207113544080" loading="lazy"></p><p><strong>（3）AOT 的优点</strong></p><p>**简单来讲，**Java 虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少 Java 应用给人带来“第一次运行慢” 的不良体验。</p><p>在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗 可以在程序运行初期就达到最高性能，程序启动速度快 运行产物只有机器码，打包体积小</p><p><strong>AOT 的缺点</strong></p><p>由于是静态提前编译，不能根据硬件情况或程序运行情况择优选择机器指令序列，理论峰值性能不如 JIT 没有动态能力，同一份产物不能跨平台运行</p><p>第一种即时编译 (JIT) 是默认模式，Java Hotspot 虚拟机使用它在运行时将字节码转换为机器码。后者提前编译 (AOT)由新颖的 GraalVM 编译器支持，并允许在构建时将字节码直接静态编译为机器码。</p><p>现在正处于云原生，降本增效的时代，Java 相比于 Go、Rust 等其他编程语言非常大的弊端就是启动编译和启动进程非常慢，这对于根据实时计算资源，弹性扩缩容的云原生技术相冲突，Spring6 借助 AOT 技术在运行时内存占用低，启动速度快，逐渐的来满足 Java 在云原生时代的需求，对于大规模使用 Java 应用的商业公司可以考虑尽早调研使用 JDK17，通过云原生技术为公司实现降本增效。</p><h3 id="_11-1-2-graalvm" tabindex="-1">11.1.2 Graalvm <a class="header-anchor" href="#_11-1-2-graalvm" aria-label="Permalink to &quot;11.1.2 Graalvm&quot;">​</a></h3><p>Spring6 支持的 AOT 技术，这个 GraalVM 就是底层的支持，Spring 也对 GraalVM 本机映像提供了一流的支持。GraalVM 是一种高性能 JDK，旨在加速用 Java 和其他 JVM 语言编写的应用程序的执行，同时还为 JavaScript、Python 和许多其他流行语言提供运行时。 GraalVM 提供两种运行 Java 应用程序的方法：在 HotSpot JVM 上使用 Graal 即时 (JIT) 编译器或作为提前 (AOT) 编译的本机可执行文件。 GraalVM 的多语言能力使得在单个应用程序中混合多种编程语言成为可能，同时消除了外语调用成本。GraalVM 向 HotSpot Java 虚拟机添加了一个用 Java 编写的高级即时 (JIT) 优化编译器。</p><p>GraalVM 具有以下特性：</p><p>（1）一种高级优化编译器，它生成更快、更精简的代码，需要更少的计算资源</p><p>（2）AOT 本机图像编译提前将 Java 应用程序编译为本机二进制文件，立即启动，无需预热即可实现最高性能</p><p>（3）Polyglot 编程在单个应用程序中利用流行语言的最佳功能和库，无需额外开销</p><p>（4）高级工具在 Java 和多种语言中调试、监视、分析和优化资源消耗</p><p>总的来说对云原生的要求不算高短期内可以继续使用 2.7.X 的版本和 JDK8，不过 Spring 官方已经对 Spring6 进行了正式版发布。</p><h3 id="_11-1-3-native-image" tabindex="-1">11.1.3 Native Image <a class="header-anchor" href="#_11-1-3-native-image" aria-label="Permalink to &quot;11.1.3 Native Image&quot;">​</a></h3><p>目前业界除了这种在 JVM 中进行 AOT 的方案，还有另外一种实现 Java AOT 的思路，那就是直接摒弃 JVM，和 C/C++一样通过编译器直接将代码编译成机器代码，然后运行。这无疑是一种直接颠覆 Java 语言设计的思路，那就是 GraalVM Native Image。它通过 C 语言实现了一个超微缩的运行时组件 —— Substrate VM，基本实现了 JVM 的各种特性，但足够轻量、可以被轻松内嵌，这就让 Java 语言和工程摆脱 JVM 的限制，能够真正意义上实现和 C/C++一样的 AOT 编译。这一方案在经过长时间的优化和积累后，已经拥有非常不错的效果，基本上成为 Oracle 官方首推的 Java AOT 解决方案。 Native Image 是一项创新技术，可将 Java 代码编译成独立的本机可执行文件或本机共享库。在构建本机可执行文件期间处理的 Java 字节码包括所有应用程序类、依赖项、第三方依赖库和任何所需的 JDK 类。生成的自包含本机可执行文件特定于不需要 JVM 的每个单独的操作系统和机器体系结构。</p><h2 id="_11-2-演示-native-image-构建过程" tabindex="-1">11.2 演示 Native Image 构建过程 <a class="header-anchor" href="#_11-2-演示-native-image-构建过程" aria-label="Permalink to &quot;11.2 演示 Native Image 构建过程&quot;">​</a></h2><h3 id="_11-2-1-graalvm-安装" tabindex="-1">11.2.1 GraalVM 安装 <a class="header-anchor" href="#_11-2-1-graalvm-安装" aria-label="Permalink to &quot;11.2.1 GraalVM 安装&quot;">​</a></h3><h4 id="_1-下载-graalvm" tabindex="-1">（1）下载 GraalVM <a class="header-anchor" href="#_1-下载-graalvm" aria-label="Permalink to &quot;（1）下载 GraalVM&quot;">​</a></h4><p>进入官网下载：<a href="https://www.graalvm.org/downloads/" target="_blank" rel="noreferrer">https://www.graalvm.org/downloads/</a></p><p><img src="'+g+'" alt="image-20221207153944132" loading="lazy"></p><p><img src="'+h+'" alt="image-20221207152841304" loading="lazy"></p><h4 id="_2-配置环境变量" tabindex="-1">（2）配置环境变量 <a class="header-anchor" href="#_2-配置环境变量" aria-label="Permalink to &quot;（2）配置环境变量&quot;">​</a></h4><p><strong>添加 GRAALVM_HOME</strong></p><p><img src="'+m+'" alt="image-20221207110539954" loading="lazy"></p><p><strong>把 JAVA_HOME 修改为 graalvm 的位置</strong></p><p><img src="'+d+'" alt="image-20221207153724340" loading="lazy"></p><p><strong>把 Path 修改位 graalvm 的 bin 位置</strong></p><p><img src="'+c+'" alt="image-20221207153755732" loading="lazy"></p><p><strong>使用命令查看是否安装成功</strong></p><p><img src="'+_+'" alt="image-20221207153642253" loading="lazy"></p><h4 id="_3-安装-native-image-插件" tabindex="-1">（3）安装 native-image 插件 <a class="header-anchor" href="#_3-安装-native-image-插件" aria-label="Permalink to &quot;（3）安装 native-image 插件&quot;">​</a></h4><p><strong>使用命令 gu install native-image 下载安装</strong></p><p><img src="'+k+'" alt="image-20221207155009832" loading="lazy"></p><h3 id="_11-2-2-安装-c-的编译环境" tabindex="-1">11.2.2 安装 C++的编译环境 <a class="header-anchor" href="#_11-2-2-安装-c-的编译环境" aria-label="Permalink to &quot;11.2.2 安装 C++的编译环境&quot;">​</a></h3><h4 id="_1-下载-visual-studio-安装软件" tabindex="-1">（1）下载 Visual Studio 安装软件 <a class="header-anchor" href="#_1-下载-visual-studio-安装软件" aria-label="Permalink to &quot;（1）下载 Visual Studio 安装软件&quot;">​</a></h4><p><a href="https://visualstudio.microsoft.com/zh-hans/downloads/" target="_blank" rel="noreferrer">https://visualstudio.microsoft.com/zh-hans/downloads/</a></p><p><img src="'+u+'" alt="image-20221219112426052" loading="lazy"></p><h4 id="_2-安装-visual-studio" tabindex="-1">（2）安装 Visual Studio <a class="header-anchor" href="#_2-安装-visual-studio" aria-label="Permalink to &quot;（2）安装 Visual Studio&quot;">​</a></h4><p><img src="'+v+'" alt="image-20221207155726572" loading="lazy"></p><p><img src="'+b+'" alt="image-20221207155756512" loading="lazy"></p><h4 id="_3-添加-visual-studio-环境变量" tabindex="-1">（3）添加 Visual Studio 环境变量 <a class="header-anchor" href="#_3-添加-visual-studio-环境变量" aria-label="Permalink to &quot;（3）添加 Visual Studio 环境变量&quot;">​</a></h4><p>配置 INCLUDE、LIB 和 Path</p><p><img src="'+J+'" alt="image-20221207110947997" loading="lazy"></p><p><img src="'+y+'" alt="image-20221207111012582" loading="lazy"></p><p><img src="'+E+'" alt="image-20221207111105569" loading="lazy"></p><h4 id="_4-打开工具-在工具中操作" tabindex="-1">（4）打开工具，在工具中操作 <a class="header-anchor" href="#_4-打开工具-在工具中操作" aria-label="Permalink to &quot;（4）打开工具，在工具中操作&quot;">​</a></h4><p><img src="'+q+`" alt="image-20221207111206279" loading="lazy"></p><h3 id="_11-2-3-编写代码-构建-native-image" tabindex="-1">11.2.3 编写代码，构建 Native Image <a class="header-anchor" href="#_11-2-3-编写代码-构建-native-image" aria-label="Permalink to &quot;11.2.3 编写代码，构建 Native Image&quot;">​</a></h3><h4 id="_1-编写-java-代码" tabindex="-1">（1）编写 Java 代码 <a class="header-anchor" href="#_1-编写-java-代码" aria-label="Permalink to &quot;（1）编写 Java 代码&quot;">​</a></h4><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Hello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello world&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_2-复制文件到目录-执行编译" tabindex="-1">（2）复制文件到目录，执行编译 <a class="header-anchor" href="#_2-复制文件到目录-执行编译" aria-label="Permalink to &quot;（2）复制文件到目录，执行编译&quot;">​</a></h4><p><img src="`+T+'" alt="image-20221207111420056" loading="lazy"></p><h4 id="_3-native-image-进行构建" tabindex="-1">（3）Native Image 进行构建 <a class="header-anchor" href="#_3-native-image-进行构建" aria-label="Permalink to &quot;（3）Native Image 进行构建&quot;">​</a></h4><p><img src="'+A+'" alt="image-20221207111509837" loading="lazy"></p><p><img src="'+V+'" alt="image-20221207111609878" loading="lazy"></p><h4 id="_4-查看构建的文件" tabindex="-1">（4）查看构建的文件 <a class="header-anchor" href="#_4-查看构建的文件" aria-label="Permalink to &quot;（4）查看构建的文件&quot;">​</a></h4><p><img src="'+f+'" alt="image-20221207111644950" loading="lazy"></p><h4 id="_5-执行构建的文件" tabindex="-1">（5）执行构建的文件 <a class="header-anchor" href="#_5-执行构建的文件" aria-label="Permalink to &quot;（5）执行构建的文件&quot;">​</a></h4><p><img src="'+w+'" alt="image-20221207111731150" loading="lazy"></p><p>可以看到这个 Hello 最终打包产出的二进制文件大小为 11M，这是包含了 SVM 和 JDK 各种库后的大小，虽然相比 C/C++的二进制文件来说体积偏大，但是对比完整 JVM 来说，可以说是已经是非常小了。</p><p>相比于使用 JVM 运行，Native Image 的速度要快上不少，cpu 占用也更低一些，从官方提供的各类实验数据也可以看出 Native Image 对于启动速度和内存占用带来的提升是非常显著的：</p><p><img src="'+z+'" alt="image-20221207111947283" loading="lazy"></p><p><img src="'+C+'" alt="image-20221207112009852" loading="lazy"></p>',77);function O(D,P,I,S,F,N){const s=i("a-back-top"),e=i("reading-progress-bar");return o(),n("div",null,[x,a(s),a(e)])}const j=t(M,[["render",O]]);export{B as __pageData,j as default};
