import{$ as i,U as l,c as e,aA as n,ab as s,S as r}from"./chunks/framework.BDLhZlrp.js";const _=JSON.parse('{"title":"7. Listener 监听器","description":"","frontmatter":{"prev":{"text":"Filter 过滤器","link":"/backend/javaweb/javaweb06"},"next":false},"headers":[],"relativePath":"backend/javaweb/javaweb07.md","filePath":"backend/javaweb/javaweb07.md","lastUpdated":1717049326000}'),o={name:"backend/javaweb/javaweb07.md"},p=n(`<h1 id="_7-listener-监听器" tabindex="-1">7. Listener 监听器 <a class="header-anchor" href="#_7-listener-监听器" aria-label="Permalink to &quot;7. Listener 监听器&quot;">​</a></h1><h2 id="_7-1-什么是监听器" tabindex="-1">7.1 什么是监听器？ <a class="header-anchor" href="#_7-1-什么是监听器" aria-label="Permalink to &quot;7.1 什么是监听器？&quot;">​</a></h2><ul><li>监听器是 Servlet 规范中的一员。就像 Filter 一样。Filter 也是 Servlet 规范中的一员。</li><li>在 Servlet 中，所有的监听器接口都是以“Listener”结尾。</li></ul><h2 id="_7-2-监听器有什么用" tabindex="-1">7.2 监听器有什么用？ <a class="header-anchor" href="#_7-2-监听器有什么用" aria-label="Permalink to &quot;7.2 监听器有什么用？&quot;">​</a></h2><ul><li>监听器实际上是 Servlet 规范留给我们 javaweb 程序员的特殊时机。</li><li>特殊的时刻如果想执行这段代码，你需要想到使用对应的监听器。</li></ul><h2 id="_7-3-servlet-规范中提供了哪些监听器" tabindex="-1">7.3 Servlet 规范中提供了哪些监听器？ <a class="header-anchor" href="#_7-3-servlet-规范中提供了哪些监听器" aria-label="Permalink to &quot;7.3 Servlet 规范中提供了哪些监听器？&quot;">​</a></h2><h3 id="jakarta-servlet-包" tabindex="-1">jakarta.servlet 包 <a class="header-anchor" href="#jakarta-servlet-包" aria-label="Permalink to &quot;jakarta.servlet 包&quot;">​</a></h3><ul><li><code>ServletContextListener</code></li><li><code>ServletContextAttributeListener</code></li><li><code>ServletRequestListener</code></li><li><code>ServletRequestAttributeListener</code></li></ul><h3 id="jakarta-servlet-http-包" tabindex="-1">jakarta.servlet.http 包 <a class="header-anchor" href="#jakarta-servlet-http-包" aria-label="Permalink to &quot;jakarta.servlet.http 包&quot;">​</a></h3><ul><li><p><code>HttpSessionListener</code></p></li><li><p><code>HttpSessionAttributeListener</code></p><ol><li><p>该监听器需要使用 @WebListener 注解进行标注。</p></li><li><p>该监听器监听的是什么？是 session 域中数据的变化。只要数据变化，则执行相应的方法。主要监测点在 session 域对象上。</p></li></ol></li><li><p><code>HttpSessionBindingListener</code></p><ol><li><p>该监听器不需要使用@WebListener 进行标注。</p></li><li><p>假设 User 类实现了该监听器，那么 User 对象在被放入 session 的时候触发 bind 事件，User 对象从 session 中删除的时候，触发 unbind 事件。</p></li><li><p>假设 Customer 类没有实现该监听器，那么 Customer 对象放入 session 或者从 session 删除的时候，不会触发 bind 和 unbind 事件。</p></li></ol></li><li><p><code>HttpSessionIdListener</code></p><p>session 的 id 发生改变的时候，监听器中的唯一一个方法就会被调用。</p></li><li><p><code>HttpSessionActivationListener</code></p><ol><li><p>监听 session 对象的钝化和活化的。</p></li><li><p>钝化：session 对象从内存存储到硬盘文件。</p></li><li><p>活化：从硬盘文件把 session 恢复到内存。</p></li></ol></li></ul><h2 id="_7-4-实现一个监听器的步骤" tabindex="-1">7.4 实现一个监听器的步骤 <a class="header-anchor" href="#_7-4-实现一个监听器的步骤" aria-label="Permalink to &quot;7.4 实现一个监听器的步骤&quot;">​</a></h2><p>以 ServletContextListener 为例，实现一个监听器的步骤如下：</p><p>第一步：编写一个类实现 ServletContextListener 接口。并且实现里面的方法。</p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> contextInitialized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ServletContextEvent event)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> contextDestroyed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ServletContextEvent event)</span></span></code></pre></div><p>第二步：在 web.xml 文件中对 ServletContextListener 进行配置，如下：</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">listener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">listener-class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;com.bjpowernode.javaweb.listener.MyServletContextListener&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">listener-class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">listener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>当然，第二步也可以不使用配置文件，也可以用注解，例如：@WebListener。</p><p>注意：所有监听器中的方法都是不需要 javaweb 程序员调用的，由服务器来负责调用？什么时候被调用呢？当某个特殊的事件发生（特殊的事件发生其实就是某个时机到了）之后，被 web 服务器自动调用。</p>`,18);function h(d,c,k,v,b,u){const t=s("a-back-top"),a=s("reading-progress-bar");return r(),l("div",null,[p,e(t),e(a)])}const g=i(o,[["render",h]]);export{_ as __pageData,g as default};
