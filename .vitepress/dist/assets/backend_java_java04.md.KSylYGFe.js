import{$ as t,U as n,c as i,aA as e,ab as s,S as h}from"./chunks/framework.BDLhZlrp.js";const k="/knowledge-map/assets/image-9.BvuLcT5h.png",r="/knowledge-map/assets/image-10.CXjMZzEn.png",A=JSON.parse('{"title":"4. 数组","description":"","frontmatter":{"prev":{"text":"类和对象","link":"/backend/java/java03"},"next":{"text":"异常","link":"/backend/java/java05"}},"headers":[],"relativePath":"backend/java/java04.md","filePath":"backend/java/java04.md","lastUpdated":1717049326000}'),p={name:"backend/java/java04.md"},d=e('<h1 id="_4-数组" tabindex="-1">4. 数组 <a class="header-anchor" href="#_4-数组" aria-label="Permalink to &quot;4. 数组&quot;">​</a></h1><h2 id="_4-1-数组概述" tabindex="-1">4.1 数组概述 ⭐ <a class="header-anchor" href="#_4-1-数组概述" aria-label="Permalink to &quot;4.1 数组概述 :star:&quot;">​</a></h2><h3 id="什么是数组" tabindex="-1">什么是数组？ <a class="header-anchor" href="#什么是数组" aria-label="Permalink to &quot;什么是数组？&quot;">​</a></h3><ul><li>在 Java 中，数组是一种用于存储多个相同数据类型元素的容器。</li><li>例如一个存储整数的数组：<code>int[] nums = {100, 200, 300};</code></li><li>例如一个存储字符串的数组：<code>String[] names = {“jack”,“lucy”,“lisi”};</code></li><li>数组是一种引用数据类型，隐式继承 Object。因此数组也可以调用 Object 类中的方法。</li><li>数组对象存储在堆内存中。</li></ul><p><img src="'+k+`" alt="alt text" loading="lazy"></p><h3 id="数组的分类" tabindex="-1">数组的分类？ <a class="header-anchor" href="#数组的分类" aria-label="Permalink to &quot;数组的分类？&quot;">​</a></h3><ul><li>根据维数进行分类：一维数组，二维数组，三维数组，多维数组。</li><li>根据数组中存储的元素类型分类：基本类型数组，引用类型数组。</li><li>根据数组初始化方式不同分类：静态数组，动态数组。</li></ul><h3 id="java-数组存储元素的特点" tabindex="-1">Java 数组存储元素的特点？ <a class="header-anchor" href="#java-数组存储元素的特点" aria-label="Permalink to &quot;Java 数组存储元素的特点？&quot;">​</a></h3><ul><li>数组长度一旦确定不可变。</li><li>数组中元素数据类型一致，每个元素占用空间大小相同。</li><li>数组中每个元素在空间存储上，内存地址是连续的。</li><li>每个元素有索引，首元素索引 0，以 1 递增。</li><li>以首元素的内存地址作为数组对象在堆内存中的地址。</li><li>所有数组对象都有 length 属性用来获取数组元素个数。末尾元素下标：length-1。</li></ul><h3 id="数组的优缺点" tabindex="-1">数组的优缺点 <a class="header-anchor" href="#数组的优缺点" aria-label="Permalink to &quot;数组的优缺点&quot;">​</a></h3><ol><li>数组优点</li></ol><ul><li>根据下标查询某个元素的效率极高。数组中有 100 个元素和有 100 万个元素，查询效率相同。时间复杂度 O(1)。也就是说在数组中根据下标查询某个元素时，不管数组的长短，耗费时间是固定不变的。</li><li>原因：知道首元素内存地址，元素在空间存储上内存地址又是连续的，每个元素占用空间大小相同，只要知道下标，就可以通过数学表达式计算出来要查找元素的内存地址。直接通过内存地址定位元素。</li></ul><ol start="2"><li>数组缺点</li></ol><ul><li>随机增删元素的效率较低。因为随机增删元素时，为了保证数组中元素的内存地址连续，就需要涉及到后续元素的位移问题。时间复杂度 O(n)。O(n)表示的是线性阶，随着问题规模 n 的不断增大，时间复杂度不断增大，算法的执行效率越低。（不过需要注意的是：对数组末尾元素的增删效率是不受影响的。）</li><li>无法存储大量数据，因为很难在内存上找到非常大的一块连续的内存。</li></ul><h2 id="_4-2-一维数组" tabindex="-1">4.2 一维数组 ✅ <a class="header-anchor" href="#_4-2-一维数组" aria-label="Permalink to &quot;4.2 一维数组 :white_check_mark:&quot;">​</a></h2><ol><li>一维数组是线性结构。二维数组，三维数组，多维数组是非线性结构。</li><li>如何静态初始化一维数组？</li></ol><ul><li>第一种：<code>int[] arr = {55,67,22};</code> 或者 <code>int arr[] = {55,67,22};</code></li><li>第二种：<code>int[] arr = new int[]{55,67,22};</code></li></ul><ol start="3"><li>如何访问数组中的元素？</li></ol><ul><li>通过下标来访问。</li><li>注意 <code>ArrayIndexOutOfBoundsException</code> 异常的发生。</li></ul><ol start="4"><li>如何遍历数组？</li></ol><ul><li>普通 for 循环遍历</li><li>for-each 遍历（优点是代码简洁。缺点是没有下标。）</li></ul><ol start="5"><li>如何动态初始化一维数组？</li></ol><ul><li><code>int[] arr = new int[4];</code></li><li><code>Object[] objs = new Object[5];</code></li><li>数组动态初始化的时候，确定长度，并且数组中每个元素采用默认值。</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><ol><li>方法在调用时如何给方法传一个数组对象？</li></ol><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 方式一：</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] arr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 方式二：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[]{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 方式三：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span></code></pre></div><ol start="2"><li>当一维数组中存储引用时的内存图 <img src="`+r+`" alt="alt text" loading="lazy"></li><li>如何获取数组中的最大值？</li></ol><ul><li>假设首元素是最大的，然后遍历数组中所有元素，只要有更大的，就将其作为最大值。</li><li>思考：找出最大值的下标怎么做？</li></ul><ol start="4"><li>如果知道值，如何通过值找它的下标？</li><li>如何将数组中的所有元素反转？</li></ol><ul><li>第一种方式：创建一个新的数组。</li><li>第二种方式：首位交换。</li></ul><ol start="6"><li>关于 main 方法的形参 args？</li></ol><ul><li>接收命令行参数</li><li>在 DOS 命令窗口中怎么传？在 IDEA 中怎么传？(Edit Configurations)</li></ul><ol start="7"><li>关于方法的可变长度参数？</li></ol><ul><li>可变长参数只能出现在形参列表中的最后一个位置。</li><li>可变长参数可以当做数组来处理。</li></ul><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">... nums) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></div><h3 id="一维数组的扩容" tabindex="-1">一维数组的扩容 <a class="header-anchor" href="#一维数组的扩容" aria-label="Permalink to &quot;一维数组的扩容&quot;">​</a></h3><ol><li>数组长度一旦确定不可变。</li><li>那数组应该如何扩容？</li></ol><ul><li>只能创建一个更大的数组将原数组中的数据全部拷贝到新数组中;</li><li>可以使用 <code>System.arraycopy()</code> 方法完成数组的拷贝。</li></ul><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] sourceArr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">24</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">66</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">78</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">99</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] newArr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[sourceArr.length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line highlighted"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">arraycopy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sourceArr, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,newArr,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sourceArr.length);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newArr.length; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newArr[i]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>数组扩容会影响程序的执行效率，因此尽可能预测数据量，创建一个接近数量的数组，减少扩容次数。</p><h2 id="_4-3-二维数组" tabindex="-1">4.3 二维数组 ✅ <a class="header-anchor" href="#_4-3-二维数组" aria-label="Permalink to &quot;4.3 二维数组 :white_check_mark:&quot;">​</a></h2><ol><li><p>二维数组是一个特殊的一维数组，特殊在：这个一维数组中每个元素是一个一维数组。</p></li><li><p>二维数组的静态初始化</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">inJ[][] arr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[][]{{},{},{}};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[][] arr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {{},{},{}};</span></span></code></pre></div></li><li><p>二维数组的动态初始化(等长)</p></li></ol><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[][] arr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span></code></pre></div><ol start="4"><li>二维数组的动态初始化（不等长）</li></ol><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[][] arr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][];</span></span></code></pre></div><ol start="5"><li>二维数组中元素的访问 <ul><li>第一个元素：<code>arr[0][0]</code>;</li><li>最后一个元素：<code>arr[arr.length-1][arr[arr.length-1].length-1]</code>。</li></ul></li><li>二维数组中元素的遍历 略</li></ol><h2 id="_4-4-idea-的-debug-调试" tabindex="-1">4.4 IDEA 的 Debug 调试 ✅ <a class="header-anchor" href="#_4-4-idea-的-debug-调试" aria-label="Permalink to &quot;4.4 IDEA 的 Debug 调试 :white_check_mark:&quot;">​</a></h2><ul><li>在可能出现问题的代码附近添加断点，一般是将断点添加在方法体的某一行代码上；</li><li>断点可以添加多个。点一次添加一个断点。再点一次断点则消失；</li><li>添加断点后，如果想让程序运行到断点处停下来，需要使用 Debug 模式运行程序；</li><li>Debug 窗口中的按钮；</li><li>给断点添加条件；</li><li>Debug 窗口中的隐藏按钮</li></ul><h2 id="_4-5-junit-单元测试" tabindex="-1">4.5 JUnit 单元测试 ✅ <a class="header-anchor" href="#_4-5-junit-单元测试" aria-label="Permalink to &quot;4.5 JUnit 单元测试 :white_check_mark:&quot;">​</a></h2><ol><li>什么是单元测试，为什么要进行单元测试？ 一个项目是巨大的，只有保证你写的每一块都是正确的，最后整个项目才能正常运行。这里所谓的每一块就是一个单元。</li><li>做单元测试需要引入 JUnit 框架，JUnit 框架在 JDK 中没有，需要额外引入，也就是引入 JUnit 框架的 class 文件（jar 包）</li><li>单元测试类（测试用例）怎么写？ 单元测试类名：XxxTest</li><li>单元测试方法怎么写？</li></ol><ul><li>单元测试方法需要使用@Test 注解标注。</li><li>单元测试方法返回值类型必须是 void</li><li>单元测试方法形参个数为 0</li><li>建议单元测试方法名：testXxx</li></ul><ol start="5"><li>什么是期望值，什么是实际值？</li></ol><ul><li>期望值就是在程序执行之前，你觉得正确的输出结果应该是多少</li><li>实际值就是程序在实际运行之后得到的结果</li></ul><ol start="6"><li>常见注解：</li></ol><ul><li>@BeforeAll @AfterAll 主要用于在测试开始之前/之后执行必要的代码。被标注的方法需要是静态的。</li><li>@BeforeEach @AfterEach 主要用于在每个测试方法执行前/后执行必要的代码。</li></ul><ol start="7"><li>单元测试中使用 Scanner 失效怎么办？ 选中导航栏的 <code>Help</code>，然后选中 <code>Edit Custom VM Options...</code>，接着在 <code>IDEA64.exe.vmoptions</code> 文件中添加内容 <code>-Deditable.java.test.console=true</code>，最后在重启 IDEA 即可解决。</li></ol><h2 id="_4-6-数据结构与算法" tabindex="-1">4.6 数据结构与算法 ❌ <a class="header-anchor" href="#_4-6-数据结构与算法" aria-label="Permalink to &quot;4.6 数据结构与算法 :x:&quot;">​</a></h2><p>略</p><h2 id="_4-7-数组的排序算法" tabindex="-1">4.7 数组的排序算法 ❌ <a class="header-anchor" href="#_4-7-数组的排序算法" aria-label="Permalink to &quot;4.7 数组的排序算法 :x:&quot;">​</a></h2><p>略</p><h2 id="_4-8-数组的查找算法" tabindex="-1">4.8 数组的查找算法 ❌ <a class="header-anchor" href="#_4-8-数组的查找算法" aria-label="Permalink to &quot;4.8 数组的查找算法 :x:&quot;">​</a></h2><p>略</p><h2 id="_4-9-arrays-工具类" tabindex="-1">4.9 Arrays 工具类 ⭐ <a class="header-anchor" href="#_4-9-arrays-工具类" aria-label="Permalink to &quot;4.9 Arrays 工具类 :star:&quot;">​</a></h2><ul><li><code>Arrays.toString()</code> 方法：将数组转换成字符串</li><li><code>Arrays.deepToString()</code> 方法：可以将二维数组转换成字符串</li><li><code>Arrays.equals(int[] arr1, int[] arr2)</code> 方法：判断两个数组是否相等</li><li><code>Arrays.equals(Object[] arr1, Object[] arr2)</code> 方法</li><li><code>Arrays.deepEquals(Object[] arr1, Object[] arr2)</code> 方法：判断两个二维数组是否相等</li><li><code>Arrays.sort(int[] arr)</code> 方法：基于快速排序算法，适合小型数据量排序</li><li><code>Arrays.sort(String[] arr)</code> 方法</li><li><code>Arrays.parallelSort(int[] arr)</code> 方法：基于分治的归并排序算法，支持多核 CPU 排序，适合大数据量排序</li><li><code>int binarySearch(int[] arr, int elt)</code> 方法：二分法查找</li><li><code>Arrays.fill(int[] arr, int data)</code> 方法：填充数组</li><li><code>Arrays.fill(int[] a, int fromIndex, int toIndex, int val)</code> 方法</li><li><code>int[] Arrays.copyOf(int[] original, int newLength)</code> 方法：数组拷贝</li><li><code>int[] Arrays.copyOfRange(int[] original, int from, int to)</code></li><li><code>Arrays.asList(T... data)</code> 方法：将一组数据转换成 List 集合</li></ul>`,53);function o(E,c,g,y,u,F){const a=s("a-back-top"),l=s("reading-progress-bar");return h(),n("div",null,[d,i(a),i(l)])}const C=t(p,[["render",o]]);export{A as __pageData,C as default};
