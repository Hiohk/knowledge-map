import{$ as p,U as o,a4 as s,G as n,c as i,aA as l,ab as a,S as h}from"./chunks/framework.BDLhZlrp.js";const A=JSON.parse('{"title":"3. JSP","description":"","frontmatter":{"prev":{"text":"Servlet","link":"/backend/javaweb/javaweb02"},"next":{"text":"EL 表达式","link":"/backend/javaweb/javaweb04"}},"headers":[],"relativePath":"backend/javaweb/javaweb03.md","filePath":"backend/javaweb/javaweb03.md","lastUpdated":1717049326000}'),k={name:"backend/javaweb/javaweb03.md"},r=l(`<h1 id="_3-jsp" tabindex="-1">3. JSP <a class="header-anchor" href="#_3-jsp" aria-label="Permalink to &quot;3. JSP&quot;">​</a></h1><h2 id="_3-1-session" tabindex="-1">3.1 Session <a class="header-anchor" href="#_3-1-session" aria-label="Permalink to &quot;3.1 Session&quot;">​</a></h2><h3 id="什么是会话" tabindex="-1">什么是会话？ <a class="header-anchor" href="#什么是会话" aria-label="Permalink to &quot;什么是会话？&quot;">​</a></h3><ul><li>会话对应的英语单词：session。</li><li>用户打开浏览器，进行一系列操作，然后最终将浏览器关闭，这个整个过程叫做：一次会话。会话在服务器端也有一个对应的 java 对象，这个 java 对象叫做：session。</li><li>什么是一次请求：用户在浏览器上点击了一下，然后到页面停下来，可以粗略认为是一次请求。请求对应的服务器端的 java 对象是：request。</li><li>一个会话当中包含多次请求。（一次会话对应 N 次请求）</li></ul><p>● 在 java 的 servlet 规范当中，session 对应的类名：HttpSession（<code>jarkata.servlet.http.HttpSession</code>）</p><p>● session 机制属于 B/S 结构的一部分。如果使用 php 语言开发 WEB 项目，同样也是有 session 这种机制的。session 机制实际上是一个规范。不同的语言对这种会话机制都有实现。</p><p>● session 对象最主要的作用是：保存会话状态。（用户登录成功了，这是一种登录成功的状态，你怎么把登录成功的状态一直保存下来呢？使用 session 对象可以保留会话状态。）</p><h3 id="为什么需要-session-对象来保存会话状态呢" tabindex="-1">为什么需要 session 对象来保存会话状态呢？ <a class="header-anchor" href="#为什么需要-session-对象来保存会话状态呢" aria-label="Permalink to &quot;为什么需要 session 对象来保存会话状态呢？&quot;">​</a></h3><ul><li>因为 HTTP 协议是一种无状态协议。</li><li>什么是无状态：请求的时候，B 和 S 是连接的，但是请求结束之后，连接就断了。为什么要这么做？HTTP 协议为什么要设计成这样？因为这样的无状态协议，可以降低服务器的压力。请求的瞬间是连接的，请求结束之后，连接断开，这样服务器压力小。</li><li>只要 B 和 S 断开了，那么关闭浏览器这个动作，服务器知道吗？ 不知道。服务器是不知道浏览器关闭的。</li></ul><p>● 张三打开一个浏览器 A，李四打开一个浏览器 B，访问服务器之后，在服务器端会生成：</p><pre><code>  ○ 张三专属的 session 对象

  ○ 李四专属的 session 对象
</code></pre><p>● 为什么不使用 request 对象保存会话状态？为什么不使用 ServletContext 对象保存会话状态？</p><ul><li>request.setAttribute()存，request.getAttribute()取，ServletContext 也有这个方法。request 是请求域，ServletContext 是应用域。</li><li>request 是一次请求一个对象。</li><li>ServletContext 对象是服务器启动的时候创建，服务器关闭的时候销毁，这个 ServletContext 对象只有一个。</li><li>ServletContext 对象的域太大。</li><li>request 请求域（HttpServletRequest）、session 会话域（HttpSession）、application 域（ServletContext）。</li><li>域范围比较：request &lt; session &lt; application。</li></ul><h4 id="session-的实现原理" tabindex="-1">session 的实现原理 <a class="header-anchor" href="#session-的实现原理" aria-label="Permalink to &quot;session 的实现原理&quot;">​</a></h4><ol><li>获取 session：</li></ol><ul><li><code>HttpSession session = request.getSession()</code>：从服务器中获取对应的 session 对象，如果没有获取到任何 session 对象，那么就会创建一个 session 对象。</li><li><code>HttpSession session = request.getSession(false)</code>：从服务器中获取对应的 session 对象，如果没有获取到任何 session 对象，那么就返回 null。</li><li>这行代码很神奇。张三访问的时候获取的 session 对象就是张三的。李四访问的时候获取的 session 对象就是李四的。</li></ul><ol start="2"><li>实现原理</li></ol><ul><li><p>客户端第一次访问服务器的时候，服务器会生成一个 session 对象，同时生成一个 id。</p></li><li><p>JSESSIONID=xxxxxx 这个是以 Cookie 的形式保存在浏览器的内存中的。浏览器只要关闭。这个 cookie 就没有了。</p></li><li><p>session 列表是一个 Map，map 的 key 是 sessionid，map 的 value 是 session 对象。</p></li><li><p>用户第一次请求，服务器生成 session 对象，同时生成 id，将 id 发送给浏览器。</p></li><li><p>用户第二次请求，自动将浏览器内存中的 id 发送给服务器，服务器根据 id 查找 session 对象。</p></li><li><p>关闭浏览器，内存消失，cookie 消失，sessionid 消失，会话等同于结束。</p></li></ul><ol start="3"><li>session 对象的销毁</li></ol><ul><li>超时销毁</li><li>手动销毁</li></ul><h3 id="cookie-禁用了-session-还能找到吗" tabindex="-1">Cookie 禁用了，session 还能找到吗？ <a class="header-anchor" href="#cookie-禁用了-session-还能找到吗" aria-label="Permalink to &quot;Cookie 禁用了，session 还能找到吗？&quot;">​</a></h3><ul><li><p>cookie 禁用是什么意思？服务器正常发送 cookie 给浏览器，但是浏览器不要了，拒收了，并不是服务器不发了。</p></li><li><p>找不到了，每一次请求都会获取到新的 session 对象。</p></li><li><p>cookie 禁用了，session 机制还能实现吗？</p><p>■ 可以。需要使用 URL 重写机制。</p><p>■ <code>http://localhost:8080/servlet12/test/session;jsessionid=19D1C99560DCBF84839FA43D58F56E16</code></p><p>■ URL 重写机制会提高开发者的成本。开发人员在编写任何请求路径的时候，后面都要添加一个 sessionid，给开发带来了很大的难度，很大的成本。所以大部分的网站都是这样设计的：你要是禁用 cookie，你就别用了。</p></li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li><p>request（对应的类名：HttpServletRequest）: 请求域（请求级别的）</p></li><li><p>session（对应的类名：HttpSession）: 会话域（用户级别的）</p></li><li><p>application（对应的类名：ServletContext）: 应用域（项目级别的，所有用户共享的）</p></li><li><p>这三个域对象的大小关系: request &lt; session &lt; application</p></li><li><p>他们三个域对象都有以下三个公共的方法：</p><p>■ setAttribute（向域当中绑定数据）</p><p>■ getAttribute（从域当中获取数据）</p><p>■ removeAttribute（删除域当中的数据）</p></li><li><p>使用原则：尽量使用小的域。</p></li></ul><p>session 掌握之后，我们怎么解决 oa 项目中的登录问题，怎么能让登录起作用。登录成功之后，可以将用户的登录信息存储到 session 当中。也就是说 session 中如果有用户的信息就代表用户登录成功了。session 中没有用户信息，表示用户没有登录过。则跳转到登录页面。</p><p>销毁 session 对象：</p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">session.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invalidate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h2 id="_3-2-cookie" tabindex="-1">3.2 Cookie <a class="header-anchor" href="#_3-2-cookie" aria-label="Permalink to &quot;3.2 Cookie&quot;">​</a></h2><ol><li>session 的实现原理中，每一个 session 对象都会关联一个 sessionid，例如：</li></ol><ul><li>JSESSIONID=41C481F0224664BDB28E95081D23D5B8</li><li>以上的这个键值对数据其实就是 cookie 对象。</li><li>对于 session 关联的 cookie 来说，这个 cookie 是被保存在浏览器的“运行内存”当中。</li><li>只要浏览器不关闭，用户再次发送请求的时候，会自动将运行内存中的 cookie 发送给服务器。</li><li>例如，这个 Cookie: JSESSIONID=41C481F0224664BDB28E95081D23D5B8 就会再次发送给服务器。</li><li>服务器就是根据 41C481F0224664BDB28E95081D23D5B8 这个值来找到对应的 session 对象的。</li></ul><ol start="2"><li>cookie 怎么生成？cookie 保存在什么地方？cookie 有什么用？浏览器什么时候会发送 cookie，发送哪些 cookie 给服务器？</li></ol><ul><li><p>cookie 最终是保存在浏览器客户端上的。</p><ul><li>可以保存在运行内存中。（浏览器只要关闭 cookie 就消失了。）</li><li>也可以保存在硬盘文件中。（永久保存。）</li></ul></li><li><p>cookie 有啥用呢？</p><ul><li>cookie 和 session 机制其实都是为了保存会话的状态。</li><li>cookie 是将会话的状态保存在浏览器客户端上。（cookie 数据存储在浏览器客户端上）</li><li>session 是将会话的状态保存在服务器端上。（session 对象是存储在服务器上）</li><li>为什么要有 cookie 和 session 机制呢？因为 HTTP 协议是无状态 无连接协议。</li></ul></li></ul><ol start="3"><li><p>cookie 的经典案例</p><p>(1) 京东商城，在未登录的情况下，向购物车中放几件商品。然后关闭商城，再次打开浏览器，访问京东商城的时候，购物车中的商品还在，这是怎么做的？我没有登录，为什么购物车中还有商品呢？</p><p>将购物车中的商品编号放到 cookie 当中，cookie 保存在硬盘文件当中。这样即使关闭浏览器。硬盘上的 cookie 还在。下一次再打开京东商城的时候，查看购物车的时候，会自动读取本地硬盘中存储的 cookie，拿到商品编号，动态展示购物车中的商品。</p><p>京东存储购物车中商品的 cookie 可能是这样的：productIds=xxxxx,yyyy,zzz,kkkk。注意：cookie 如果清除掉，购物车中的商品就消失了。</p><p>(2) 126 邮箱中有一个功能：十天内免登录</p><p>这个功能也是需要 cookie 来实现的。怎么实现的呢？</p><p>用户输入正确的用户名和密码，并且同时选择十天内免登录。登录成功后。浏览器客户端会保存一个 cookie，这个 cookie 中保存了用户名和密码等信息，这个 cookie 是保存在硬盘文件当中的，十天有效。在十天内用户再次访问 126 的时候，浏览器自动提交 126 的关联的 cookie 给服务器，服务器接收到 cookie 之后，获取用户名和密码，验证，通过之后，自动登录成功。</p><p>(3) 怎么让 cookie 失效？</p><p>○ 十天过后自动失效;</p><p>○ 或者改密码;</p><p>○ 或者在客户端浏览器上清除 cookie。</p></li><li><p>cookie 机制和 session 机制其实都不属于 java 中的机制，实际上 cookie 机制和 session 机制都是 HTTP 协议的一部分。php 开发中也有 cookie 和 session 机制，只要是你是做 web 开发，不管是什么编程语言，cookie 和 session 机制都是需要的。</p></li><li><p>HTTP 协议中规定：任何一个 cookie 都是由 name 和 value 组成的。name 和 value 都是字符串类型的。</p></li><li><p>在 java 的 servlet 中，对 cookie 提供了哪些支持呢？</p><ul><li><p>提供了一个 Cookie 类来专门表示 cookie 数据: <code>jakarta.servlet.http.Cookie</code>;</p></li><li><p>java 程序怎么把 cookie 数据发送给浏览器呢？<code>response.addCookie(Cookie cookie);</code></p></li></ul></li><li><p>在 HTTP 协议中是这样规定的：当浏览器发送请求的时候，会自动携带该 path 下的 cookie 数据给服务器。（URL）</p></li><li><p>关于 cookie 的有效时间</p></li></ol><ul><li><p>怎么用 java 设置 cookie 的有效时间</p><p><code>cookie.setMaxAge(60 * 60)</code>: 设置 cookie 在一小时之后失效。</p></li><li><p>没有设置有效时间：默认保存在浏览器的运行内存中，浏览器关闭则 cookie 消失。</p></li><li><p>只要设置 cookie 的有效时间 &gt; 0，这个 cookie 一定会存储到硬盘文件当中。</p></li><li><p>设置 cookie 的有效时间 = 0 呢？</p><p>cookie 被删除，同名 cookie 被删除。</p></li><li><p>设置 cookie 的有效时间 &lt; 0 呢？</p><p>保存在运行内存中。和不设置一样。</p></li></ul><ol start="9"><li>关于 cookie 的 path，cookie 关联的路径：</li></ol><ul><li><p>假设现在发送的请求路径是 <code>http://localhost:8080/servlet13/cookie/generate</code> 生成的 cookie，如果 cookie 没有设置 path，默认的 path 是什么？</p><p>默认的 path 是：<code>http://localhost:8080/servlet13/cookie</code> 以及它的子路径。</p><p>也就是说，以后只要浏览器的请求路径是 <code>http://localhost:8080/servlet13/cookie</code> 这个路径以及这个路径下的子路径，cookie 都会被发送到服务器。</p></li><li><p>手动设置 cookie 的 path</p><p><code>cookie.setPath(&quot;/servlet13&quot;)</code>: 表示只要是这个 servlet13 项目的请求路径，都会提交这个 cookie 给服务器。</p></li></ul><ol start="10"><li>浏览器发送 cookie 给服务器了，服务器中的 java 程序怎么接收？</li></ol><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Cookie</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] cookies </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> request.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getCookies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这个方法可能返回null</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cookies </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Cookie cookie </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cookies){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 获取cookie的name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        String name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cookie.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 获取cookie的value</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        String value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cookie.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="11"><li>使用 cookie 实现一下十天内免登录功能</li></ol><ul><li><p>先实现登录功能</p><p>■ 登录成功, 跳转到部门列表页面</p><p>■ 登录失败, 跳转到登录失败页面</p></li><li><p>修改前端页面</p><p>■ 在登录页面给一个复选框，复选框后面给一句话：十天内免登录。</p><p>■ 用户选择了复选框：表示要支持十天内免登录。</p><p>■ 用户没有选择复选框：表示用户不想使用十天内免登录功能。</p></li><li><p>修改 Servlet 中的 login 方法</p><p>如果用户登录成功了，并且用户登录时选择了十天内免登录功能，这个时候应该在 Servlet 的 login 方法中创建 cookie，用来存储用户名和密码，并且设置路径，设置有效期，将 cookie 响应给浏览器。（浏览器将其自动保存在硬盘文件当中 10 天）</p></li><li><p>用户再次访问该网站的时候，访问这个网站的首页的时候，有两个走向:</p><p>■ 要么跳转到部门列表页面</p><p>■ 要么跳转到登录页面</p><p>■ 以上分别有两个走向，这显然是需要编写 java 程序进行控制的。</p></li></ul><h2 id="_3-3-jsp" tabindex="-1">3.3 JSP <a class="header-anchor" href="#_3-3-jsp" aria-label="Permalink to &quot;3.3 JSP&quot;">​</a></h2><h3 id="jsp-的本质" tabindex="-1">JSP 的本质 <a class="header-anchor" href="#jsp-的本质" aria-label="Permalink to &quot;JSP 的本质&quot;">​</a></h3><ul><li>index.jsp 访问的时候，会自动翻译生成 index_jsp.java，会自动编译生成 index_jsp.class，那么 index_jsp 这就是一个类。</li><li>index_jsp 类继承 HttpJspBase，而 HttpJspBase 类继承的是 HttpServlet。所以 index_jsp 类就是一个 Servlet 类。</li><li>jsp 的生命周期和 Servlet 的生命周期完全相同。完全就是一个东西。没有任何区别。</li><li>jsp 和 servlet 一样，都是单例的。（假单例。）</li></ul><h3 id="为什么-jsp-文件第一次访问的时候是比较慢" tabindex="-1">为什么 jsp 文件第一次访问的时候是比较慢？ <a class="header-anchor" href="#为什么-jsp-文件第一次访问的时候是比较慢" aria-label="Permalink to &quot;为什么 jsp 文件第一次访问的时候是比较慢？&quot;">​</a></h3><ul><li>为什么大部分的运维人员在给客户演示项目的时候，为什么提前先把所有的 jsp 文件先访问一遍。</li><li>第一次比较麻烦： <ul><li>要把 jsp 文件翻译生成 java 源文件</li><li>java 源文件要编译生成 class 字节码文件</li><li>然后通过 class 去创建 servlet 对象</li><li>然后调用 servlet 对象的 init 方法</li><li>最后调用 servlet 对象的 service 方法。</li></ul></li><li>第二次就比较快了，为什么？ 因为第二次直接调用单例 servlet 对象的 service 方法即可。</li></ul><h3 id="jsp-是什么" tabindex="-1">JSP 是什么？ <a class="header-anchor" href="#jsp-是什么" aria-label="Permalink to &quot;JSP 是什么？&quot;">​</a></h3><ul><li><p>JSP 是 java 程序。（JSP 本质还是一个 Servlet）</p></li><li><p>JSP 是：JavaServer Pages 的缩写。（基于 Java 语言实现的服务器端的页面。）</p></li><li><p>Servlet 是 JavaEE 的 13 个子规范之一，那么 JSP 也是 JavaEE 的 13 个子规范之一。</p></li><li><p>JSP 是一套规范。所有的 web 容器/web 服务器都是遵循这套规范的，都是按照这套规范进行的“翻译”。</p></li><li><p>每一个 web 容器/web 服务器都会内置一个 JSP 翻译引擎。</p></li><li><p>对 JSP 进行错误调试的时候，还是要直接打开 JSP 文件对应的 java 文件，检查 java 代码。</p></li></ul><h3 id="jsp-和-servlet-的区别" tabindex="-1">JSP 和 Servlet 的区别 <a class="header-anchor" href="#jsp-和-servlet-的区别" aria-label="Permalink to &quot;JSP 和 Servlet 的区别&quot;">​</a></h3><p>职责不同：</p>`,49),c=s("li",null,"Servlet 的职责是什么：收集数据。（Servlet 的强项是逻辑处理，业务处理，然后链接数据库，获取/收集数据。）",-1),d=l(`<h3 id="jsp-的基础语法" tabindex="-1">JSP 的基础语法 <a class="header-anchor" href="#jsp-的基础语法" aria-label="Permalink to &quot;JSP 的基础语法&quot;">​</a></h3><h4 id="在-jsp-文件中直接编写文字-都会自动被翻译到哪里" tabindex="-1">在 jsp 文件中直接编写文字，都会自动被翻译到哪里？ <a class="header-anchor" href="#在-jsp-文件中直接编写文字-都会自动被翻译到哪里" aria-label="Permalink to &quot;在 jsp 文件中直接编写文字，都会自动被翻译到哪里？&quot;">​</a></h4><ul><li>翻译到 servlet 类的 service 方法的 out.write(&quot;翻译到这里&quot;)，直接翻译到双引号里，被 java 程序当做普通字符串打印输出到浏览器。</li><li>在 JSP 中编写的 HTML, CSS, JS 代码，这些代码对于 JSP 来说只是一个普通的字符串。但是 JSP 把这个普通的字符串一旦输出到浏览器，浏览器就会对 HTML, CSS, JS 进行解释执行, 渲染出界面。</li></ul><h4 id="jsp-的-page-指令-这个指令后面再详细说-这里先解决一下中文乱码问题-解决响应时的中文乱码问题" tabindex="-1">JSP 的 page 指令（这个指令后面再详细说，这里先解决一下中文乱码问题），解决响应时的中文乱码问题： <a class="header-anchor" href="#jsp-的-page-指令-这个指令后面再详细说-这里先解决一下中文乱码问题-解决响应时的中文乱码问题" aria-label="Permalink to &quot;JSP 的 page 指令（这个指令后面再详细说，这里先解决一下中文乱码问题），解决响应时的中文乱码问题：&quot;">​</a></h4><p>通过 page 指令来设置响应的内容类型，在内容类型的最后面添加：charset=UTF-8</p><ul><li><code>&lt;%@page contentType=&quot;text/html;charset=UTF-8&quot;%&gt;</code>，表示响应的内容类型是 text/html，采用的字符集 UTF-8</li><li><code>&lt;%@page import=&quot;java.util.List,java.util.ArrayList&quot;%&gt;</code></li></ul><h4 id="怎么在-jsp-中编写-java-程序" tabindex="-1">怎么在 JSP 中编写 Java 程序： <a class="header-anchor" href="#怎么在-jsp-中编写-java-程序" aria-label="Permalink to &quot;怎么在 JSP 中编写 Java 程序：&quot;">​</a></h4><ol><li><p><strong><code>&lt;% java 语句; %&gt;</code></strong></p><ul><li>在这个符号当中编写的被视为 java 程序，被翻译到 Servlet 类的 service 方法内部。</li><li>这里你要细心点，你要思考，在&lt;% %&gt;这个符号里面写 java 代码的时候，你要时时刻刻的记住你正在“方法体”当中写代码，方法体中可以写什么，不可以写什么，你心里是否明白呢？</li><li>在 service 方法当中编写的代码是有顺序的，方法体当中的代码要遵循自上而下的顺序依次逐行执行。 - service 方法当中不能写静态代码块，不能写方法，不能定义成员变量。。。。。。</li><li>在同一个 JSP 当中 &lt;%%&gt; 这个符号可以出现多个。</li></ul></li><li><p><strong><code>&lt;%! %&gt;</code></strong></p><ul><li>在这个符号当中编写的 java 程序会自动翻译到 service 方法之外。</li><li>这个语法很少用，为什么？不建议使用，因为在 service 方法外面写静态变量和实例变量，都会存在线程安全问题，因为 JSP 就是 servlet，servlet 是单例的，多线程并发的环境下，这个静态变量和实例变量一旦有修改操作，必然会存在线程安全问题。</li></ul></li><li><p><strong>JSP 的输出语句</strong></p><ul><li><p>怎么向浏览器上输出一个 java 变量。</p></li><li><p>&lt;% String name = “jack”; out.write(&quot;name = &quot; + name); %&gt;</p></li><li><p>注意：以上代码中的 out 是 JSP 的九大内置对象之一。可以直接拿来用。当然，必须只能在 service 方法内部使用。</p></li><li><p>如果向浏览器上输出的内容中没有“java 代码”，例如输出的字符串是一个固定的字符串，可以直接在 jsp 中编写，不需要写到&lt;%%&gt; 这里。</p></li><li><p>如果输出的内容中含有“java 代码”，这个时候可以使用以下语法格式：</p><p>○ &lt;%= %&gt; 注意：在=的后面编写要输出的内容。</p><p>○ &lt;%= %&gt; 这个符号会被翻译到哪里？最终翻译成什么？</p><pre><code>1）翻译成了这个java代码： out.print();

2）翻译到service方法当中了。
</code></pre><p>○ 什么时候使用&lt;%=%&gt; 输出呢？输出的内容中含有 java 的变量，输出的内容是一个动态的内容，不是一个死的字符串。如果输出的是一个固定的字符串，直接在 JSP 文件中编写即可。</p></li></ul></li><li><p><strong>在 JSP 中如何编写 JSP 的专业注释</strong></p><ul><li>&lt;%--JSP 的专业注释，不会被翻译到 java 源代码当中。--%&gt;</li></ul></li><li><p><strong>JSP 基础语法总结</strong></p><ul><li><p>JSP 中直接编写普通字符串</p><p>翻译到 service 方法的 out.write(&quot;这里&quot;)</p></li><li><p><code>&lt;% %&gt;</code></p><p>翻译到 service 方法体内部，里面是一条一条的 java 语句。</p></li><li><p><code>&lt;%! %&gt;</code></p><p>翻译到 service 方法之外。</p></li><li><p><code>&lt;%= %&gt;</code></p><p>翻译到 service 方法体内部，翻译为：out.print();</p></li><li><p><code>&lt;%@page contentType=&quot;text/html;charset=UTF-8&quot;%&gt;</code></p><p>page 指令，通过 contentType 属性用来设置响应的内容类型。</p></li></ul></li><li><p><strong>JSP 的指令</strong></p></li></ol><ul><li><p>指令的作用：指导 JSP 的翻译引擎如何工作（指导当前的 JSP 翻译引擎如何翻译 JSP 文件。）</p></li><li><p>指令包括哪些呢？</p><p>■ include 指令：包含指令，在 JSP 中完成静态包含，很少用了。（这里不讲）</p><p>■ taglib 指令：引入标签库的指令。这**个到 JJSTL 标签库的时候再学习。现在先不管。</p><p>■ page 指令：目前重点学习一个 page 指令。</p></li><li><p>指令的使用语法是什么？</p><p>■ &lt;%@指令名 属性名=属性值 属性名=属性值 属性名=属性值....%&gt;</p></li><li><p>关于 page 指令当中都有哪些常用的属性呢？</p></li></ul><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> session</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;true|false&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> %&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true 表示启用 JSP 的内置对象 session，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 表示一定启动 session 对象。没有 session 对象会创建。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果没有设置，默认值就是 session=&quot;true&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// session=&quot;false&quot; 表示不启动内置对象 session。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 当前 JSP 页面中无法使用内置对象 session。</span></span></code></pre></div><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contentType</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text/json&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> %&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// contentType 属性用来设置响应的内容类型</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 但同时也可以设置字符集。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contentType</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text/json;charset=UTF-8&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> %&gt;</span></span></code></pre></div><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pageEncoding</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;UTF-8&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> %&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// pageEncoding=&quot;UTF-8&quot; 表示设置响应时采用的字符集。</span></span></code></pre></div><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;java.util.List, java.util.Date, java.util.ArrayList&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> %&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;java.util.*&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> %&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// import语句，导包</span></span></code></pre></div><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> errorPage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/error.jsp&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> %&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 当前页面出现异常之后，跳转到error.jsp页面。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// errorPage属性用来指定出错之后的跳转位置。</span></span></code></pre></div><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isErrorPage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;true&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> %&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 表示启用JSP九大内置对象之一：exception</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 默认值是false。</span></span></code></pre></div><ol start="7"><li><strong>JSP 的九大内置对象</strong></li></ol><ul><li><code>jakarta.servlet.jsp.PageContext</code> pageContext 页面作用域</li><li><code>jakarta.servlet.http.HttpServletRequest</code> request 请求作用域</li><li><code>jakarta.servlet.http.HttpSession</code> session 会话作用域</li><li><code>jakarta.servlet.ServletContext</code> application 应用作用域 <ul><li>pageContext &lt; request &lt; session &lt; application</li><li>以上四个作用域都有：setAttribute、getAttribute、removeAttribute 方法。</li><li>以上作用域的使用原则：尽可能使用小的域。</li></ul></li><li><code>java.lang.Throwable</code> exception</li><li><code>jakarta.servlet.ServletConfig</code> config</li><li><code>java.lang.Object</code> page （其实是 this，当前的 servlet 对象）</li><li><code>jakarta.servlet.jsp.JspWriter</code> out （负责输出）</li><li><code>jakarta.servlet.http.HttpServletResponse</code> response （负责响应）</li></ul>`,17);function g(u,v,E,y,S,b){const e=a("a-back-top"),t=a("reading-progress-bar");return h(),o("div",null,[r,s("ul",null,[c,s("li",null,[n("JSP 的职责是什么：展示数据。（JSP 的强项是做数据的展示）"),i(e)])]),d,i(e),i(t)])}const D=p(k,[["render",g]]);export{A as __pageData,D as default};
