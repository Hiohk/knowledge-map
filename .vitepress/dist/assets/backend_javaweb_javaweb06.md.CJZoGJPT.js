import{$ as s,U as a,c as i,aA as r,ab as l,S as n}from"./chunks/framework.BDLhZlrp.js";const b=JSON.parse('{"title":"6. Filter 过滤器","description":"","frontmatter":{"prev":{"text":"JSTL 标签库","link":"/backend/javaweb/javaweb05"},"next":{"text":"Listener 监听器","link":"/backend/javaweb/javaweb07"}},"headers":[],"relativePath":"backend/javaweb/javaweb06.md","filePath":"backend/javaweb/javaweb06.md","lastUpdated":1717049326000}'),p={name:"backend/javaweb/javaweb06.md"},h=r(`<h1 id="_6-filter-过滤器" tabindex="-1">6. Filter 过滤器 <a class="header-anchor" href="#_6-filter-过滤器" aria-label="Permalink to &quot;6. Filter 过滤器&quot;">​</a></h1><h2 id="_6-1-当前的-oa-项目存在什么缺陷" tabindex="-1">6.1 当前的 OA 项目存在什么缺陷？ <a class="header-anchor" href="#_6-1-当前的-oa-项目存在什么缺陷" aria-label="Permalink to &quot;6.1 当前的 OA 项目存在什么缺陷？&quot;">​</a></h2><p>DeptServlet、EmpServlet、OrderServlet。每一个 Servlet 都是处理自己相关的业务。在这些 Servlet 执行之前都是需要判断用户是否登录了。如果用户登录了，可以继续操作，如果没有登录，需要用户登录。这段判断用户是否登录的代码是固定的，并且在每一个 Servlet 类当中都需要编写，显然代码没有得到重复利用。包括每一个 Servlet 都要解决中文乱码问题，也有公共的代码。这些代码目前都是重复编写，并没有达到复用，怎么解决这个问题?</p><p>可以使用 Servlet 规范中的 Filter 过滤器来解决这个问题。</p><h2 id="_6-2-filter-是什么-有什么用-执行原理是什么" tabindex="-1">6.2 Filter 是什么，有什么用，执行原理是什么？ <a class="header-anchor" href="#_6-2-filter-是什么-有什么用-执行原理是什么" aria-label="Permalink to &quot;6.2 Filter 是什么，有什么用，执行原理是什么？&quot;">​</a></h2><ul><li>Filter 是过滤器。</li><li>Filter 可以在 Servlet 这个目标程序执行之前添加代码。也可以在目标 Servlet 执行之后添加代码。之前之后都可以添加过滤规则。</li><li>一般情况下，都是在过滤器当中编写公共代码。</li></ul><h2 id="_6-3-一个过滤器怎么写呢" tabindex="-1">6.3 一个过滤器怎么写呢？ <a class="header-anchor" href="#_6-3-一个过滤器怎么写呢" aria-label="Permalink to &quot;6.3 一个过滤器怎么写呢？&quot;">​</a></h2><ul><li><p>第一步：编写一个 Java 类实现一个接口：jarkata.servlet.Filter。并且实现这个接口当中所有的方法。</p><p><strong>init 方法</strong>：在 Filter 对象第一次被创建之后调用，并且只调用一次。</p><p><strong>doFilter 方法</strong>：只要用户发送一次请求，则执行一次。发送 N 次请求，则执行 N 次。在这个方法中编写过滤规则。</p><p><strong>destroy 方法</strong>：在 Filter 对象被释放/销毁之前调用，并且只调用一次。</p></li><li><p>第二步：在 web.xml 文件中对 Filter 进行配置。这个配置和 Servlet 很像。</p></li></ul><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter-name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;filter2&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter-name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter-class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;com.bjpowernode.javaweb.servlet.Filter2&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter-class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter-mapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter-name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;filter2&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter-name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">url-pattern</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;*.do&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">url-pattern</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">filter-mapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>或者使用注解：@WebFilter({&quot;*.do&quot;})</p><div class="tip custom-block"><p class="custom-block-title">注意：</p><ul><li>Servlet 对象默认情况下，在服务器启动的时候是不会新建对象的。</li><li>Filter 对象默认情况下，在服务器启动的时候会新建对象。</li><li>Servlet 是单例的。Filter 也是单例的。（单实例。）</li></ul></div><ol><li><strong>目标 Servlet 是否执行，取决于两个条件：</strong></li></ol><ul><li><p>第一：在过滤器当中是否编写了：chain.doFilter(request, response); 代码。</p></li><li><p>第二：用户发送的请求路径是否和 Servlet 的请求路径一致。</p></li></ul><p><code>chain.doFilter(request, response);</code> 这行代码的作用：</p><ul><li><p>执行下一个过滤器，如果下面没有过滤器了，执行最终的 Servlet。注意：Filter 的优先级，天生的就比 Servlet 优先级高。</p></li><li><p><code>/a.do</code> 对应一个 Filter，也对应一个 Servlet。那么一定是先执行 Filter，然后再执行 Servlet。</p></li></ul><ol start="2"><li><strong>关于 Filter 的配置路径：</strong></li></ol><ul><li><p><code>/a.do</code>、<code>/b.do</code>、<code>/dept/save</code>: 这些配置方式都是精确匹配。</p></li><li><p><code>/*</code> 匹配所有路径。</p></li><li><p><code>*.do</code> 后缀匹配。不要以 <code>/</code> 开始</p></li><li><p><code>/dept/*</code> 前缀匹配。</p></li></ul><ol start="3"><li><strong>在 web.xml 文件中进行配置的时候，Filter 的执行顺序是什么？</strong></li></ol><ul><li>依靠 filter-mapping 标签的配置位置，越靠上优先级越高。</li></ul><ol start="4"><li><p><strong>过滤器的调用顺序，遵循栈数据结构。</strong></p></li><li><p><strong>使用@WebFilter 的时候，Filter 的执行顺序是怎样的呢？</strong></p></li></ol><ul><li><p>执行顺序是：比较 Filter 这个类名。</p></li><li><p>比如：FilterA 和 FilterB，则先执行 FilterA。</p></li><li><p>比如：Filter1 和 Filter2，则先执行 Filter1.</p></li></ul><ol start="6"><li><strong>Filter 的生命周期？</strong></li></ol><ul><li>和 Servlet 对象生命周期一致。</li><li>唯一的区别：Filter 默认情况下，在服务器启动阶段就实例化。Servlet 不会。</li></ul><ol start="7"><li><strong>Filter 过滤器这里有一个设计模式</strong>：</li></ol><ul><li><p>责任链设计模式。</p></li><li><p>过滤器最大的优点：</p><p>在程序编译阶段不会确定调用顺序。因为 Filter 的调用顺序是配置到 web.xml 文件中的，只要修改 web.xml 配置文件中 filter-mapping 的顺序就可以调整 Filter 的执行顺序。显然 Filter 的执行顺序是在程序运行阶段动态组合的。那么这种设计模式被称为责任链设计模式。</p></li><li><p>责任链设计模式最大的核心思想：</p><p>在程序运行阶段，动态的组合程序的调用顺序。</p></li></ul>`,25);function o(k,d,E,c,g,v){const e=l("a-back-top"),t=l("reading-progress-bar");return n(),a("div",null,[h,i(e),i(t)])}const _=s(p,[["render",o]]);export{b as __pageData,_ as default};
